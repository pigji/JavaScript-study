<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>reduce 메서드</title>
</head>
<body>
  <script>
    //iterble.reduce : 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복 호출한다
    //콜백함수의 반환값을 다음 순회 시에 콜백함수의 첫번째 인수로 전달하면서 콜백함수를 호출하여 하나의 결과값을 만들어 반환한다.

    const sum = [1,2,3,4];
    //acc = 누적값, cur = 현재 순회중인 배열요소
    const num = sum.reduce((acc, cur) => acc + cur, 0)

    console.log(num)

    //평균 구하기
    const values = [1,2,3,4,5,6];
    //acc = 누적값, cur = 현재 순회중인 배열요소, i = 순회중인 배열요소의 인덱스, {length} = 배열의 갯수
    const average = values.reduce((acc, cur, i, {length}) => {
      //마지막 순회가 아니면 누적값을 반환하고 마지막 순회면 누적값으로 평균을 구해 반환한다.
      return i === length - 1 ? (acc + cur) / length : acc + cur
    }, 0)

    console.log(average)
    //values = [1,2,3,4,5,6]
    //최대값 구하기
    const max = values.reduce((acc, cur) => (acc > cur ? acc : cur), 0)
    console.log(max)

    //Math.max메서드를 사용하는 방법이 더 직관적이다.
    const max2 = Math.max(...values)
    console.log(max2)

    //요소의 중복 횟수 구하기
    const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];
    const count = fruits.reduce((acc, cur) => {
      acc[cur] = (acc[cur] || 0) + 1;
      return acc;
    },{})//첫번째 순회시 acc는 {}이다

    console.log(count)
  </script>
</body>
</html>